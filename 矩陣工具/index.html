<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>矩陣計算器 Matrix Lab</title>
  <link rel="stylesheet" href="matrix.css" />
  <style>
    /* 安全字型回退，避免中文破版 */
    :root { --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
  <header class="app-header">
    <h1>矩陣計算器 <span class="sub">Matrix&nbsp;Lab</span></h1>
    <div class="header-actions">
      <button id="btnFillDemo" class="ghost">載入示例</button>
      <button id="btnClearAll" class="ghost">全部清空</button>
      <a class="ghost" href="https://en.wikipedia.org/wiki/Matrix_(mathematics)" target="_blank" rel="noopener">矩陣快速複習 ↗</a>
    </div>
  </header>

  <main class="grid">
    <section class="panel">
      <div class="panel-head">
        <h2>A 矩陣</h2>
        <div class="dims">
          <label>列
            <input type="number" id="rowsA" min="1" max="8" value="3" />
          </label>
          <span>×</span>
          <label>行
            <input type="number" id="colsA" min="1" max="8" value="3" />
          </label>
          <button id="applyA" class="mini">套用</button>
        </div>
      </div>
      <div id="matrixA" class="matrix"></div>
      <div class="panel-foot">
        <button class="mini" id="randA">隨機</button>
        <button class="mini" id="zeroA">清空</button>
        <button class="mini" id="idenA">單位</button>
        <button class="mini" id="copyResToA">← 取用結果</button>
      </div>
    </section>

    <section class="panel">
      <div class="panel-head">
        <h2>B 矩陣</h2>
        <div class="dims">
          <label>列
            <input type="number" id="rowsB" min="1" max="8" value="3" />
          </label>
          <span>×</span>
          <label>行
            <input type="number" id="colsB" min="1" max="8" value="3" />
          </label>
          <button id="applyB" class="mini">套用</button>
        </div>
      </div>
      <div id="matrixB" class="matrix"></div>
      <div class="panel-foot">
        <button class="mini" id="randB">隨機</button>
        <button class="mini" id="zeroB">清空</button>
        <button class="mini" id="idenB">單位</button>
        <button class="mini" id="copyResToB">← 取用結果</button>
      </div>
    </section>

    <section class="panel ops">
      <div class="panel-head">
        <h2>操作</h2>
      </div>
      <div class="op-grid">
        <div class="op-group">
          <div class="op-title">二元運算</div>
          <button class="op" data-op="add">A + B</button>
          <button class="op" data-op="sub">A − B</button>
          <button class="op" data-op="mul">A × B</button>
          <button class="op" data-op="mulBA">B × A</button>
        </div>

        <div class="op-group">
          <div class="op-title">一元運算（A）</div>
          <button class="op" data-op="transposeA">Aᵀ 轉置</button>
          <button class="op" data-op="detA">det(A) 行列式</button>
          <button class="op" data-op="invA">A⁻¹ 反矩陣</button>
          <button class="op" data-op="rankA">rank(A) 秩</button>
          <button class="op" data-op="traceA">tr(A) 跡</button>
          <button class="op" data-op="rrefA">RREF(A) 簡化列階梯</button>
        </div>

        <div class="op-group">
          <div class="op-title">一元運算（B）</div>
          <button class="op" data-op="transposeB">Bᵀ 轉置</button>
          <button class="op" data-op="detB">det(B) 行列式</button>
          <button class="op" data-op="invB">B⁻¹ 反矩陣</button>
          <button class="op" data-op="rankB">rank(B) 秩</button>
          <button class="op" data-op="traceB">tr(B) 跡</button>
          <button class="op" data-op="rrefB">RREF(B) 簡化列階梯</button>
        </div>
      </div>
      <div class="note">
        小提示：支援大小 1–8，反矩陣/行列式僅限方陣；乘法需內外維度相容。
      </div>
    </section>

    <section class="panel result">
      <div class="panel-head">
        <h2>結果</h2>
        <div class="result-actions">
          <button id="copyResult">複製為 TSV</button>
          <button id="downloadCSV">下載 CSV</button>
        </div>
      </div>
      <div id="resultArea" class="matrix"></div>
      <pre id="scalarArea" class="scalar"></pre>
    </section>
  </main>

  <footer class="app-footer">
    <span>本工具以原生 JavaScript 實作高斯消去、RREF、行列式與反矩陣。</span>
  </footer>

<script>
/* ---------- DOM 工具 ---------- */
function $(sel) { return document.querySelector(sel); }
function el(tag, cls) { const e = document.createElement(tag); if (cls) e.className = cls; return e; }

/* ---------- 產生輸入格 ---------- */
function buildGrid(container, rows, cols, name) {
  container.innerHTML = "";
  const grid = el("div", "grid-input");
  for (let r = 0; r < rows; r++) {
    const row = el("div", "row");
    for (let c = 0; c < cols; c++) {
      const input = el("input", "cell");
      input.type = "text";
      input.inputMode = "decimal";
      input.placeholder = "0";
      input.value = (r === c ? "1" : "0"); // 預設單位感
      input.dataset.name = name;
      input.dataset.r = r;
      input.dataset.c = c;
      row.appendChild(input);
    }
    grid.appendChild(row);
  }
  container.appendChild(grid);
}

function getDims(prefix) {
  const rows = parseInt($("#rows" + prefix).value, 10);
  const cols = parseInt($("#cols" + prefix).value, 10);
  return {rows, cols};
}

function getMatrix(prefix) {
  const {rows, cols} = getDims(prefix);
  const m = Array.from({length: rows}, () => Array(cols).fill(0));
  const container = $("#matrix" + prefix);
  container.querySelectorAll("input.cell").forEach(inp => {
    const r = parseInt(inp.dataset.r, 10);
    const c = parseInt(inp.dataset.c, 10);
    const v = parseFloat(inp.value.replace(',', '.'));
    m[r][c] = isFinite(v) ? v : 0;
  });
  return m;
}

function setMatrix(prefix, M) {
  const rows = M.length, cols = M[0].length;
  $("#rows" + prefix).value = rows;
  $("#cols" + prefix).value = cols;
  buildGrid($("#matrix" + prefix), rows, cols, prefix);
  // 填值
  $("#matrix" + prefix).querySelectorAll("input.cell").forEach(inp => {
    const r = parseInt(inp.dataset.r, 10);
    const c = parseInt(inp.dataset.c, 10);
    const v = M[r][c];
    inp.value = Number.isFinite(v) ? String(roundSmart(v)) : "";
  });
}

function renderMatrix(container, M) {
  container.innerHTML = "";
  const grid = el("div", "grid-output");
  for (let r = 0; r < M.length; r++) {
    const row = el("div", "row");
    for (let c = 0; c < M[0].length; c++) {
      const cell = el("div", "cell");
      cell.textContent = Number.isFinite(M[r][c]) ? String(roundSmart(M[r][c])) : "";
      row.appendChild(cell);
    }
    grid.appendChild(row);
  }
  container.appendChild(grid);
}

/* ---------- 數學核心 ---------- */
function approxZero(x, eps=1e-10) { return Math.abs(x) < eps; }
function roundSmart(x) {
  // 對非常接近整數的值做漂亮的四捨五入
  const r = Math.round(x);
  if (Math.abs(x - r) < 1e-10) return r;
  // 其他值保留最多 8 位小數
  return Number.parseFloat(x.toFixed(8));
}

function clone(M) { return M.map(row => row.slice()); }

function transpose(M) {
  const R = M.length, C = M[0].length;
  const T = Array.from({length: C}, () => Array(R).fill(0));
  for (let r = 0; r < R; r++) for (let c = 0; c < C; c++) T[c][r] = M[r][c];
  return T;
}

function add(A, B) {
  if (A.length !== B.length || A[0].length !== B[0].length) throw new Error("維度不相同，無法相加。");
  const R = A.length, C = A[0].length;
  const M = Array.from({length: R}, () => Array(C).fill(0));
  for (let r = 0; r < R; r++) for (let c = 0; c < C; c++) M[r][c] = A[r][c] + B[r][c];
  return M;
}

function sub(A, B) {
  if (A.length !== B.length || A[0].length !== B[0].length) throw new Error("維度不相同，無法相減。");
  const R = A.length, C = A[0].length;
  const M = Array.from({length: R}, () => Array(C).fill(0));
  for (let r = 0; r < R; r++) for (let c = 0; c < C; c++) M[r][c] = A[r][c] - B[r][c];
  return M;
}

function mul(A, B) {
  const R = A.length, C = B[0].length, K = A[0].length;
  if (K !== B.length) throw new Error("內外維度不相容，無法相乘。");
  const M = Array.from({length: R}, () => Array(C).fill(0));
  for (let r = 0; r < R; r++) {
    for (let c = 0; c < C; c++) {
      let sum = 0;
      for (let k = 0; k < K; k++) sum += A[r][k] * B[k][c];
      M[r][c] = sum;
    }
  }
  return M;
}

// 高斯消去：RREF、rank、det、inverse
function rref(M) {
  // 回傳：[RREF 矩陣, 樞紐列索引]
  const A = clone(M).map(row => row.map(x => +x));
  const R = A.length, C = A[0].length;
  let r = 0; // 當前行
  const pivots = [];
  for (let c = 0; c < C && r < R; c++) {
    // 找尋主元
    let pivot = r;
    for (let i = r + 1; i < R; i++) if (Math.abs(A[i][c]) > Math.abs(A[pivot][c])) pivot = i;
    if (approxZero(A[pivot][c])) continue;
    // 交換
    if (pivot !== r) [A[pivot], A[r]] = [A[r], A[pivot]];
    // 正規化
    const val = A[r][c];
    for (let j = c; j < C; j++) A[r][j] /= val;
    // 歸零其他行
    for (let i = 0; i < R; i++) if (i !== r) {
      const f = A[i][c];
      if (!approxZero(f)) for (let j = c; j < C; j++) A[i][j] -= f * A[r][j];
    }
    pivots.push(c);
    r++;
  }
  // 修正很小的數值為 0
  for (let i = 0; i < R; i++) for (let j = 0; j < C; j++) if (approxZero(A[i][j])) A[i][j] = 0;
  return [A, pivots];
}

function rank(M) {
  const [R, piv] = rref(M);
  return piv.length;
}

function determinant(M) {
  // 使用 LU（簡化版）/ 高斯消去計算 det
  const n = M.length;
  if (n === 0 || M[0].length !== n) throw new Error("行列式僅適用於方陣。");
  const A = clone(M).map(row => row.map(x => +x));
  let det = 1;
  for (let c = 0; c < n; c++) {
    // 選主元
    let pivot = c;
    for (let i = c + 1; i < n; i++) if (Math.abs(A[i][c]) > Math.abs(A[pivot][c])) pivot = i;
    const pv = A[pivot][c];
    if (approxZero(pv)) return 0;
    if (pivot !== c) { [A[pivot], A[c]] = [A[c], A[pivot]]; det *= -1; }
    det *= A[c][c];
    // 消去
    for (let i = c + 1; i < n; i++) {
      const f = A[i][c] / A[c][c];
      for (let j = c; j < n; j++) A[i][j] -= f * A[c][j];
    }
  }
  return det;
}

function inverse(M) {
  const n = M.length;
  if (n === 0 || M[0].length !== n) throw new Error("反矩陣僅適用於方陣。");
  // 增廣矩陣 [M | I]
  const A = clone(M).map((row, i) => row.concat(
    Array.from({length: n}, (_, j) => (i === j ? 1 : 0))
  ));
  const R = A.length, C = A[0].length;
  let r = 0;
  for (let c = 0; c < n && r < R; c++) {
    // 選主元
    let pivot = r;
    for (let i = r + 1; i < R; i++) if (Math.abs(A[i][c]) > Math.abs(A[pivot][c])) pivot = i;
    if (approxZero(A[pivot][c])) continue;
    if (pivot !== r) [A[pivot], A[r]] = [A[r], A[pivot]];
    // 正規化
    const val = A[r][c];
    for (let j = 0; j < C; j++) A[r][j] /= val;
    // 歸零其他行
    for (let i = 0; i < R; i++) if (i !== r) {
      const f = A[i][c];
      if (!approxZero(f)) for (let j = 0; j < C; j++) A[i][j] -= f * A[r][j];
    }
    r++;
  }
  // 檢查左半是否為 I
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      if (i === j && !approxZero(A[i][j] - 1)) throw new Error("矩陣不可逆（行列式為 0）。");
      if (i !== j && !approxZero(A[i][j])) throw new Error("矩陣不可逆（行列式為 0）。");
    }
  }
  // 取右半
  const inv = Array.from({length: n}, () => Array(n).fill(0));
  for (let i = 0; i < n; i++) for (let j = 0; j < n; j++) inv[i][j] = A[i][j + n];
  return inv;
}

function trace(M) {
  const n = M.length;
  if (n === 0 || M[0].length !== n) throw new Error("跡僅適用於方陣。");
  let t = 0;
  for (let i = 0; i < n; i++) t += M[i][i];
  return t;
}

function toCSV(M) {
  return M.map(row => row.map(v => roundSmart(v)).join(",")).join("\n");
}

function toTSV(M) {
  return M.map(row => row.map(v => roundSmart(v)).join("\t")).join("\n");
}

/* ---------- UI 綁定 ---------- */
function applyDims(prefix) {
  const {rows, cols} = getDims(prefix);
  const cappedR = Math.max(1, Math.min(8, rows));
  const cappedC = Math.max(1, Math.min(8, cols));
  buildGrid($("#matrix" + prefix), cappedR, cappedC, prefix);
}

function fillRandom(prefix) {
  const cont = $("#matrix" + prefix);
  cont.querySelectorAll("input.cell").forEach(inp => {
    const v = (Math.random() * 10 - 5); // [-5, 5)
    inp.value = roundSmart(v);
  });
}

function fillZero(prefix) {
  const cont = $("#matrix" + prefix);
  cont.querySelectorAll("input.cell").forEach(inp => inp.value = "0");
}

function fillIdentity(prefix) {
  const cont = $("#matrix" + prefix);
  const rows = cont.querySelectorAll(".row").length;
  const cols = cont.querySelector(".row").children.length;
  cont.querySelectorAll("input.cell").forEach(inp => {
    const r = parseInt(inp.dataset.r, 10);
    const c = parseInt(inp.dataset.c, 10);
    inp.value = (r === c ? "1" : "0");
  });
}

function setResult(M) {
  $("#scalarArea").textContent = "";
  renderMatrix($("#resultArea"), M);
}

function setScalar(text) {
  $("#resultArea").innerHTML = "";
  $("#scalarArea").textContent = text;
}

function doOp(op) {
  try {
    const A = getMatrix("A");
    const B = getMatrix("B");
    switch (op) {
      case "add": return setResult(add(A, B));
      case "sub": return setResult(sub(A, B));
      case "mul": return setResult(mul(A, B));
      case "mulBA": return setResult(mul(B, A));
      case "transposeA": return setResult(transpose(A));
      case "transposeB": return setResult(transpose(B));
      case "detA": return setScalar("det(A) = " + roundSmart(determinant(A)));
      case "detB": return setScalar("det(B) = " + roundSmart(determinant(B)));
      case "invA": return setResult(inverse(A));
      case "invB": return setResult(inverse(B));
      case "rankA": return setScalar("rank(A) = " + rank(A));
      case "rankB": return setScalar("rank(B) = " + rank(B));
      case "traceA": return setScalar("tr(A) = " + roundSmart(trace(A)));
      case "traceB": return setScalar("tr(B) = " + roundSmart(trace(B)));
      case "rrefA": return setResult(rref(A)[0]);
      case "rrefB": return setResult(rref(B)[0]);
      default: break;
    }
  } catch (err) {
    setScalar("錯誤：" + err.message);
  }
}

function copyResultTo(prefix) {
  const table = $("#resultArea .grid-output");
  if (!table) return;
  const rows = table.querySelectorAll(".row").length;
  if (!rows) return;
  const cols = table.querySelector(".row").children.length;
  const M = Array.from({length: rows}, (_, r) =>
    Array.from({length: cols}, (_, c) => {
      const cell = table.children[r].children[c].textContent.trim();
      const num = parseFloat(cell.replace(',', '.'));
      return isFinite(num) ? num : 0;
    })
  );
  setMatrix(prefix, M);
}

function copyTextToClipboard(text) {
  const ta = el("textarea");
  ta.value = text;
  document.body.appendChild(ta);
  ta.select();
  document.execCommand("copy");
  ta.remove();
}

/* ---------- 初始化 ---------- */
function init() {
  applyDims("A");
  applyDims("B");

  $("#applyA").addEventListener("click", () => applyDims("A"));
  $("#applyB").addEventListener("click", () => applyDims("B"));
  $("#randA").addEventListener("click", () => fillRandom("A"));
  $("#randB").addEventListener("click", () => fillRandom("B"));
  $("#zeroA").addEventListener("click", () => fillZero("A"));
  $("#zeroB").addEventListener("click", () => fillZero("B"));
  $("#idenA").addEventListener("click", () => fillIdentity("A"));
  $("#idenB").addEventListener("click", () => fillIdentity("B"));
  $("#copyResToA").addEventListener("click", () => copyResultTo("A"));
  $("#copyResToB").addEventListener("click", () => copyResultTo("B"));

  document.querySelectorAll("button.op").forEach(btn => {
    btn.addEventListener("click", () => doOp(btn.dataset.op));
  });

  $("#btnFillDemo").addEventListener("click", () => {
    setMatrix("A", [
      [2, -1, 0],
      [1, 3, 4],
      [0, -2, 5]
    ]);
    setMatrix("B", [
      [1, 2, 1],
      [0, -1, 3],
      [4, 0, 2]
    ]);
    setScalar("已載入 3×3 範例：試試 det(A)、A×B 或 RREF(A)。");
  });

  $("#btnClearAll").addEventListener("click", () => {
    applyDims("A"); applyDims("B");
    $("#resultArea").innerHTML = "";
    $("#scalarArea").textContent = "";
  });

  $("#copyResult").addEventListener("click", () => {
    const table = $("#resultArea .grid-output");
    if (!table) { setScalar("沒有矩陣結果可複製。"); return; }
    const rows = table.querySelectorAll(".row").length;
    const cols = table.querySelector(".row").children.length;
    const M = Array.from({length: rows}, (_, r) =>
      Array.from({length: cols}, (_, c) => table.children[r].children[c].textContent.trim())
    );
    copyTextToClipboard(M.map(row => row.join("\t")).join("\n"));
    setScalar("已複製結果（TSV 格式）。");
  });

  $("#downloadCSV").addEventListener("click", () => {
    const table = $("#resultArea .grid-output");
    if (!table) { setScalar("沒有矩陣結果可下載。"); return; }
    const rows = table.querySelectorAll(".row").length;
    const cols = table.querySelector(".row").children.length;
    const M = Array.from({length: rows}, (_, r) =>
      Array.from({length: cols}, (_, c) => table.children[r].children[c].textContent.trim())
    );
    const csv = M.map(row => row.join(",")).join("\n");
    const blob = new Blob([csv], {type: "text/csv;charset=utf-8;"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "matrix_result.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
}

document.addEventListener("DOMContentLoaded", init);
</script>
</body>
</html>
